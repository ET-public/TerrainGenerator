// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain




#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744f

float mod289(float x) {
	return x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;
}

float2 mod289(float2 x) {
	return x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;
}

float3 mod289(float3 x) {
	return x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;
}

float4 mod289(float4 x) {
	return x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;
}

float permute(float x) {
	return mod289(
		x*x*34.0 + x
	);
}

float3 permute(float3 x) {
	return mod289(
		x*x*34.0 + x
	);
}

float4 permute(float4 x) {
	return mod289(
		x*x*34.0 + x
	);
}



float4 grad4(float j, float4 ip)
{
	const float4 ones = float4(1.0, 1.0, 1.0, -1.0);
	float4 p, s;
	p.xyz = floor( frac(j * ip.xyz) * 7.0) * ip.z - 1.0;
	p.w = 1.5 - dot( abs(p.xyz), ones.xyz );
	
	// GLSL: lessThan(x, y) = x < y
	// HLSL: 1 - step(y, x) = x < y
	p.xyz -= sign(p.xyz) * (p.w < 0);
	
	return p;
}


float snoise(float2 v)
{
	const float4 C = float4(
		0.211324865405187, // (3.0-sqrt(3.0))/6.0
		0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
	 -0.577350269189626, // -1.0 + 2.0 * C.x
		0.024390243902439  // 1.0 / 41.0
	);
	
// First corner
	float2 i = floor( v + dot(v, C.yy) );
	float2 x0 = v - i + dot(i, C.xx);
	
// Other corners
	// float2 i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
	// Lex-DRL: afaik, step() in GPU is faster than if(), so:
	// step(x, y) = x <= y
	
	// Actually, a simple conditional without branching is faster than that madness :)
	int2 i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
	float4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;
	
// Permutations
	i = mod289(i); // Avoid truncation effects in permutation
	float3 p = permute(
		permute(
				i.y + float3(0.0, i1.y, 1.0 )
		) + i.x + float3(0.0, i1.x, 1.0 )
	);
	
	float3 m = max(
		0.5 - float3(
			dot(x0, x0),
			dot(x12.xy, x12.xy),
			dot(x12.zw, x12.zw)
		),
		0.0
	);
	m = m*m ;
	m = m*m ;
	
// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
	
	float3 x = 2.0 * frac(p * C.www) - 1.0;
	float3 h = abs(x) - 0.5;
	float3 ox = floor(x + 0.5);
	float3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
	m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
	float3 g;
	g.x = a0.x * x0.x + h.x * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	return 130.0 * dot(m, g);
}




float inverseLerp(float a, float b, float value){
    return saturate((value-a)/(b-a));
}

struct kva{
    float3 pos;
};
int vkx;
float xpos;
float zpos;
float velikost;
float razdalja;
float seedx;
float seedy;
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<kva> Result;

[numthreads(32,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	
    // TODO: insert actual code here!
    float x = Result[id.x].pos.x*velikost + xpos;
    float z = Result[id.x].pos.z*velikost + zpos;
    float2 v = float2(x*0.001+1.2, z*0.001+1.3);
    float2 v4 = float2(x*0.001+435.54, z*0.00066667+345.34);
    float2 v2 = float2(z*0.00125+12.0, x*0.00123609+48.0);
    float2 v3 = float2(z*0.0002+84.0, x*0.0002+456.0);
	float2 v5 = float2(z*0.0125+84.0, x*0.0125+456.0);
    float h = snoise(v);
    h += snoise(v2);
    h += snoise(v4)*0.5;
    h += snoise(v3)*0.2;
	h += snoise(v5)*0.01;
    float maxValue = 1 +0.5 + 1 + 0.2 + 0.01;
	float mult = 180/maxValue;
	float2 t = float2(Result[id.x].pos.x*velikost + xpos - seedx, Result[id.x].pos.z*velikost + zpos - seedy);
	float dis = t.x*t.x + t.y*t.y;
	float visina = h*mult+20;
	if(dis > razdalja){
		mult = lerp(1, 0, inverseLerp(razdalja,razdalja*5, dis));
		visina *= mult;
	}
    //h = lerp(0,1, inverseLerp(0,maxValue,h));
    Result[id.x].pos = float3(Result[id.x].pos.x*velikost, visina, Result[id.x].pos.z*velikost);
}




